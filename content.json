{"meta":{"title":"Lee's Blog","subtitle":null,"description":null,"author":"Lee","url":"http://yoursite.com","root":"/"},"pages":[{"title":"Tags","date":"2019-08-02T16:51:08.000Z","updated":"2019-08-03T01:00:06.054Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""},{"title":"Categories","date":"2019-08-02T16:47:56.000Z","updated":"2019-08-03T01:00:24.805Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"About","date":"2019-08-02T16:51:54.000Z","updated":"2019-08-02T16:52:38.146Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":""}],"posts":[{"title":"C++笔记","slug":"CppTutorial","date":"2019-08-12T01:48:18.000Z","updated":"2019-08-12T03:53:04.110Z","comments":true,"path":"2019/08/12/CppTutorial/","link":"","permalink":"http://yoursite.com/2019/08/12/CppTutorial/","excerpt":"","text":"C++基础语法命名空间关键字：namespace 命名空间将全局作用域分成不同部分，不同命名空间中的标识符可以相同，命名空间可以嵌套，全局作用域也叫做默认命名空间。 1234567891011121314namespace A &#123; int x = 0; void fun();&#125;namespace B &#123; int x = 1; void fun();&#125;A::x; // 访问A命名空间的x变量A::fun(); // 调用A命名空间的fun函数B::x;B::fun(); 引用 &amp; 指针 引用是变量的别名，不存在空引用，必须初始化！ 一旦引用被初始化为一个对象，就不能被指向到另一个对象；指针可以在任何时候指向到另一个对象。 引用必须在创建时被初始化；指针可以在任何时间被初始化。 123456789101112131415161718192021// 基本数据类型的引用int a = 3;int &amp; b = a;// 结构体的引用typedef struct &#123; int x; int y;&#125; Coor;/*C语言结构体只是一种数据的集合，不作为变量类型，定义变量时仍需要使用struct关键字；C++则认为结构体是一种数据变量；*/Coor c1;Coor &amp; c = c1;// 指针类型的引用： 类型 *&amp; 指针引用名 = 指针；int a = 10;int * p = &amp;a;int *&amp; q = p; // 指针的引用*q = 20; const const与基本数据类型 const与指针 底层const（*前，指向对象的值不能修改） 顶层const（*后，所存储的内存地址不能变） const与引用 12345const int x = 3; // 常量xconst int *p = nullptr; // *p是常量int const *p = nullptr; // *p是常量int * const p = nullptr; // p是常量 内存管理 申请内存new （注意内存分配失败） 释放内存delete 1234567891011int * p = new int;delete p;p = null; // 删除了指针p所指的对象，但指针变量p本身仍存在int * arr = new int [10];delete [] arr;arr = null;// C语言方式：malloc函数和free函数(void *) malloc(size_t size);void free(void * memeblock); 封装 数据封装 数据封装是一种把数据和操作数据的函数捆绑在一起的机制； 数据抽象 数据抽象是一种仅向用户暴露接口而把具体的实现细节隐藏起来的机制； 类和对象 访问限定符 public protected private 对象实例化 从栈实例化 从堆实例化 12345678910class Node &#123;public: int val; Node * left; Node * right; Node(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;&#125;;Node node(2); // 栈实例化Node * p = new Node(2); // 堆实例化 内存分区 栈区：int x = 0; int *p = nullptr; 堆区：int *p = new int[20]; 全局区：存储全局变量及静态变量 常量区：string str = &quot;Hello&quot;; 代码区：存储逻辑代码的二进制数据 数据封装 定义在public说明符之后的成员在整个程序内可以被访问，public成员定义类的接口； 定义在private说明符之后的成员可以被类的成员函数访问，但是不能被使用该类的代码访问，private封装了（隐藏了）类的实现细节； 123456789class Student &#123;public: Student(string name, int age) : _name(name), _age(age) &#123;&#125; void setAge(int age) &#123;_age = age;&#125; int getAge() &#123;return _age;&#125;private: string _name; int _age;&#125;; 内联函数内联函数：inline关键字，编译时用函数体代码和实参代替函数调用语句； 对于类内定义的函数，编译器优先编译为内联函数； 123inline int max(int a, int b) &#123; // 关键字inline必须与函数定义在一起 return a &gt; b ? a : b;&#125; 构造函数 构造函数初始化列表 默认构造函数 12Student() &#123;&#125;Student(name = \"Jim\", age = 20) &#123;_name = name; _age = age;&#125; 初始化列表 1Student(string name, int age) : _name(name), _age(age) &#123;&#125; 初始化列表特性 初始化列表先于构造函数执行； 初始化列表只能用于构造函数； 初始化列表可以同时初始化多个数据成员；","categories":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/categories/C/"}],"tags":[]},{"title":"Vector","slug":"Vector","date":"2019-08-03T16:38:39.000Z","updated":"2020-04-12T08:56:24.477Z","comments":true,"path":"2019/08/04/Vector/","link":"","permalink":"http://yoursite.com/2019/08/04/Vector/","excerpt":"","text":"To be done.","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/categories/数据结构/"}],"tags":[]},{"title":"二叉树遍历","slug":"binary-tree-traverse","date":"2019-08-03T01:26:12.000Z","updated":"2019-08-03T08:58:13.178Z","comments":true,"path":"2019/08/03/binary-tree-traverse/","link":"","permalink":"http://yoursite.com/2019/08/03/binary-tree-traverse/","excerpt":"","text":"二叉树的前序、中序、后序遍历实现 递归版本1234567891011121314151617181920212223242526// 前序遍历void preOrderRec(Node * node) &#123; if (node != nullptr) &#123; cout &lt;&lt; node-&gt;val; preOrderRec(node-&gt;left); preOrderRec(node-&gt;right); &#125;&#125;// 中序遍历void inOrderRec(Node * node) &#123; if (node != nullptr) &#123; inOrderRec(node-&gt;left); cout &lt;&lt; node-&gt;data; inOrderRec(node-&gt;right); &#125;&#125;// 后序遍历void postOrderRec(Node * node) &#123; if (node != nullptr) &#123; postOrderRec(node-&gt;left); postOrderRec(node-&gt;right); cout &lt;&lt; node-&gt;data; &#125;&#125; 非递归版本123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051// 前序遍历void preOrderIte() &#123; stack&lt;Node *&gt; s; if (root != nullptr) &#123; s.push(root); while (!s.empty()) &#123; Node * cur = s.top(); s.pop(); cout &lt;&lt; cur-&gt;data; if (cur-&gt;right != nullptr) s.push(cur-&gt;right); if (cur-&gt;left != nullptr) s.push(cur-&gt;left); &#125; &#125;&#125;// 中序遍历void inOrderIte() &#123; stack&lt;Node *&gt; s; Node * cur = root; while (cur != nullptr || !s.empty()) &#123; while (cur != nullptr) &#123; s.push(cur); cur = cur-&gt;left; &#125; Node * node = s.top(); s.pop(); cout &lt;&lt; node-&gt;data; if (node-&gt;right != nullptr) cur = node-&gt;right; &#125;&#125;// 后序遍历void postOrderIte() &#123; stack&lt;Node *&gt; s; if (root != nullptr) &#123; s.push(root); Node * pre = nullptr; // 记录前一个被访问的节点 while (!s.empty()) &#123; Node * cur = s.top(); if ((cur-&gt;left == nullptr &amp;&amp; cur-&gt;right == nullptr) || cur-&gt;left == pre || cur-&gt;right == pre) &#123; cout &lt;&lt; cur-&gt;data; s.pop(); pre = cur; &#125; else &#123; if (cur-&gt;right != nullptr) s.push(cur-&gt;right); if (cur-&gt;left != nullptr) s.push(cur-&gt;left); &#125; &#125; &#125;&#125; 完整代码基于类模板实现二叉树的前序、中序、后序遍历 Node类12345678template &lt;typename T&gt;class Node &#123;public: T data; Node&lt;T&gt; * left; Node&lt;T&gt; * right; Node(T x) : data(x), left(nullptr), right(nullptr) &#123;&#125;&#125;; Tree类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140template &lt;typename T&gt;class Tree &#123;public: Tree(); ~Tree(); void preOrderRec(); // 前序遍历递归版，调用preOrderRec(node)函数 void inOrderRec(); // 中序遍历递归版 void postOrderRec(); // 后序遍历递归版 void preOrderIte(); // 前序遍历迭代版 void inOrderIte(); // 中序遍历迭代版 void postOrderIte(); // 后序遍历迭代版private: Node&lt;T&gt; * root; void remove(Node&lt;T&gt; * node); // 删除以node为根的子树 void preOrderRec(Node&lt;T&gt; * node); void inOrderRec(Node&lt;T&gt; * node); void postOrderRec(Node&lt;T&gt; * node);&#125;;// 函数实现template &lt;typename T&gt;Tree&lt;T&gt;::Tree() &#123; // 简单测试，构造函数直接建立一棵树 // root root = new Node&lt;T&gt;(2); // depth = 1 root-&gt;left = new Node&lt;T&gt;(1); root-&gt;right = new Node&lt;T&gt;(3); // depth = 2 root-&gt;left-&gt;left = new Node&lt;T&gt;(4); root-&gt;left-&gt;right = new Node&lt;T&gt;(5); root-&gt;right-&gt;right = new Node&lt;T&gt;(7);&#125;template &lt;typename T&gt;Tree&lt;T&gt;::~Tree() &#123; remove(root);&#125;template &lt;typename T&gt;void Tree&lt;T&gt;::remove(Node&lt;T&gt; * node) &#123; if (node-&gt;left != nullptr) remove(node-&gt;left); if (node-&gt;right != nullptr) remove(node-&gt;right); cout &lt;&lt; \"Deleting node \" &lt;&lt; node-&gt;data &lt;&lt; endl; delete node; node = nullptr;&#125;template &lt;typename T&gt;void Tree&lt;T&gt;::preOrderRec() &#123; preOrderRec(root);&#125;template &lt;typename T&gt;void Tree&lt;T&gt;::preOrderRec(Node&lt;T&gt; * node) &#123; if (node != nullptr) &#123; cout &lt;&lt; node-&gt;data; // 访问节点（打印） preOrderRec(node-&gt;left); preOrderRec(node-&gt;right); &#125;&#125;template &lt;typename T&gt;void Tree&lt;T&gt;::inOrderRec() &#123; inOrderRec(root);&#125;template &lt;typename T&gt;void Tree&lt;T&gt;::inOrderRec(Node&lt;T&gt; * node) &#123; if (node != nullptr) &#123; inOrderRec(node-&gt;left); cout &lt;&lt; node-&gt;data; // 访问节点（打印） inOrderRec(node-&gt;right); &#125;&#125;template &lt;typename T&gt;void Tree&lt;T&gt;::postOrderRec() &#123; postOrderRec(root);&#125;template &lt;typename T&gt;void Tree&lt;T&gt;::postOrderRec(Node&lt;T&gt; * node) &#123; if (node != nullptr) &#123; postOrderRec(node-&gt;left); postOrderRec(node-&gt;right); cout &lt;&lt; node-&gt;data; // 访问节点（打印） &#125;&#125;template &lt;typename T&gt;void Tree&lt;T&gt;::preOrderIte() &#123; stack&lt;Node&lt;T&gt; *&gt; s; if (root != nullptr) &#123; s.push(root); while (!s.empty()) &#123; Node&lt;T&gt; * cur = s.top(); s.pop(); cout &lt;&lt; cur-&gt;data; // 访问节点（打印） if (cur-&gt;right != nullptr) s.push(cur-&gt;right); if (cur-&gt;left != nullptr) s.push(cur-&gt;left); &#125; &#125;&#125;template &lt;typename T&gt;void Tree&lt;T&gt;::inOrderIte() &#123; stack&lt;Node&lt;T&gt; *&gt; s; Node&lt;T&gt; * cur = root; while (cur != nullptr || !s.empty()) &#123; while (cur != nullptr) &#123; s.push(cur); cur = cur-&gt;left; &#125; Node&lt;T&gt; * node = s.top(); s.pop(); cout &lt;&lt; node-&gt;data; // 访问节点（打印） if (node-&gt;right != nullptr) cur = node-&gt;right; &#125;&#125;template &lt;typename T&gt;void Tree&lt;T&gt;::postOrderIte() &#123; stack&lt;Node&lt;T&gt; *&gt; s; if (root != nullptr) &#123; s.push(root); Node&lt;T&gt; * pre = nullptr; // 记录前一个被访问的节点 while (!s.empty()) &#123; Node&lt;T&gt; * cur = s.top(); if ((cur-&gt;left == nullptr &amp;&amp; cur-&gt;right == nullptr) || cur-&gt;left == pre || cur-&gt;right == pre) &#123; cout &lt;&lt; cur-&gt;data; // 访问节点（打印） s.pop(); pre = cur; &#125; else &#123; if (cur-&gt;right != nullptr) s.push(cur-&gt;right); if (cur-&gt;left != nullptr) s.push(cur-&gt;left); &#125; &#125; &#125;&#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/categories/数据结构/"}],"tags":[]},{"title":"Git Notes","slug":"Git-Notes","date":"2019-08-02T16:38:53.000Z","updated":"2019-08-03T01:28:59.728Z","comments":true,"path":"2019/08/03/Git-Notes/","link":"","permalink":"http://yoursite.com/2019/08/03/Git-Notes/","excerpt":"","text":"记录Git（Github）学习笔记。 安装配置与基本使用安装配置123456789101112git config --global user.name \"user_name\"git config --global user.email \"user_email@domain.com\"# 其他选项git config --local #对某个仓库有效git config --system #对系统所有登陆用户有效# 查看config配置git config --listgit config --list --localgit config --list --globalgit config --list --system 创建Git仓库1234567# 已有代码纳入Git仓库cd project_foldergit init# 新建项目git init project_namecd project 本地提交12345678910111213141516171819202122232425262728vim README.mdgit add README.mdgit commit -m \"Add README.md file.\"git log # 查看版本历史# 其他选项git status # 查看仓库当前状态git add -u # add所有文件git add file1 file2 # add两个文件git commit -am \"Commit from workstage.\" # 工作区内容直接commit，被追踪(tracked)但未暂存(unstaged)可使用-a -m直接提交# 查看提交历史git log --oneline # 单行显示log信息git log -n2 # 显示最近两次log信息git log --onelien -n3git log --all # 查看所有分支日志git log --all --graph # 图形化方式显示所有日志信息git log --oneline --all --graph -n4git log --oneline brach_name # 查看分支日志git help log # 查看git log帮助文档git help log --web # 浏览器查看git log帮助文档gitk # 图形化方式查看版本历史# 查看分支信息git branch -v # 查看本地分支信息git branch -av # 好看所有分支信息 查看文件差异123456789101112git diff filename# 其他选项git diff # 默认比较工作区和暂存区的差异git diff --cached # 比较暂存区和HEAD的差异git diff -- filename # 比较工作区和暂存区的filename差异git diff branch_a branch_b -- filename # 比较两个分支文件的差异git diff commit_a commit_b # 比较两个commit的差异git diff HEAD HEAD^1^1git diff HEAD HEAD~2 撤销修改12345# 丢弃工作区的修改git checkout -- file# 撤销暂存区的修改git reset HEAD file # 工作区未撤销 文件重命名123456789# 方式一mv README.md Readme.mdgit rm README.mdgit add Readme.mdgit commit -m \"Rename README.md to Readme.md\"# 方式二git mv README.md Radme.mdgit commit -m \"Rename README.md to Readme.md\" 删除文件12git rm filenamegit commit -m \"Delete filename.\" 版本回退123456git reset --hard commit_id # 回退到某一个commit版本git reset --hard HEAD^1 # 回退HEAD前一个版本git reset --hard HEAD~3 # 回退HEAD前三个版本# 其他选项git reflog # 查看命令历史","categories":[{"name":"Git笔记","slug":"Git笔记","permalink":"http://yoursite.com/categories/Git笔记/"}],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2019-08-02T03:38:53.000Z","updated":"2019-08-03T01:28:55.319Z","comments":true,"path":"2019/08/02/hello-world/","link":"","permalink":"http://yoursite.com/2019/08/02/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[{"name":"Hexo笔记","slug":"Hexo笔记","permalink":"http://yoursite.com/categories/Hexo笔记/"}],"tags":[]}]}